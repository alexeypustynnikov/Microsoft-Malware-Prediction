import pandas as pd
import numpy as np
from datetime import datetime
import time
import math
import matplotlib.pyplot as plt
import os
from tqdm import tqdm_notebook

import plotly
import plotly.offline as py
import plotly.graph_objs as go
from plotly import tools
from sklearn.model_selection import train_test_split
py.init_notebook_mode(connected=False)


class EDA_utils:
    
    #constructor
    def __init__(self, path_train, path_test = None, id_column = None, responce = None, dtypes= None, band_suffix = '_banded'):
        
        #Initialize train and test data objects
        #Create list of chunks to append later
        def create_chunk_list(reader, lines_number, lines_in_chunk, type):
            chunk_list = []
            current_row = 0
            desc = 'Loading ' + type + ' Data'
            with tqdm_notebook(total=lines_number, desc = desc) as pbar:
                for chunk in reader:
                    chunk_list.append(chunk)
                    #updating bar
                    if lines_number - current_row >= lines_in_chunk:
                        pbar.update(lines_in_chunk)
                    else:
                        pbar.update(lines_number - current_row) #for the case when size of last remaining chunk less than lines_in_chunk
            
                    current_row = current_row + lines_in_chunk
            return chunk_list
        
        #chunks constant -- load N=lines_in_chunk lines per iteration when possible
        lines_in_chunk = 50000
        #number of lines in data train file
        lines_number = sum(1 for line in open(path_train))
        
        #define chunks object
        reader = pd.read_csv(path_train, chunksize=lines_in_chunk, dtype = dtypes)
        chunk_list = create_chunk_list(reader, lines_number, lines_in_chunk, 'Train')

        #join all chunks togather
        self.data_train = pd.concat(chunk_list)
        
        #add test data optionally
        if path_test is not None:
            lines_number = sum(1 for line in open(path_test))
            reader = pd.read_csv(path_test, chunksize=lines_in_chunk, dtype = dtypes)
            chunk_list = create_chunk_list(reader, lines_number, lines_in_chunk, 'Test')
          
            self.data_test = pd.concat(chunk_list)
        
        #Add various data parameters
        
        #primary key (unique and not null) column
        self.id_column = id_column

        #dictionary for banding
        self.banding_dict = {}

        #dictionary for banding suffixes
        self.banding_dict_suff = {}

        #responce (binary) column
        self.responce = responce
        '''
        #define which suffix to add for banded variables
        self.band_suffix = band_suffix
        '''
        #definition of "factor_list" that depends on assignment of id_column and responce
        self.factor_list = self.data_train.columns.values.tolist()
        if responce is not None:
            self.factor_list.remove(responce)
        if id_column is not None:
            self.factor_list.remove(id_column)

        self.mean_proba = self.data_train[self.responce].sum() / len(self.data_train[self.responce])
     
    #method to add new factor
    #Parameters:
    #   1) fac_name -- name of new factor
    #   2) fac_data_train -- data to be added to train data
    #   3) fac_data_test -- data to be added to test data (optional)
    def add_factor(self, fac_name, fac_data_train, fac_data_test = None):
        self.data_train[fac_name] = fac_data_train
        if fac_data_test is not None:
            self.data_test[fac_name] = fac_data_test
        self.factor_list.append(fac_name)
    
    #method that generates missed values statistics
    #Parameters:
    #   1) type_ -- train or test data flag
    def null_stats(self, type_='train'):
        def get_null_stats(df, type_):
            print('calculate ' + type_+ ' missing data:')
            total = df.isnull().sum().sort_values(ascending = False)
            percent = (df.isnull().sum()/df.isnull().count()*100).sort_values(ascending = False)
            missing_data  =  pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])
            return missing_data
        if type_ not in ['train', 'test']:
            raise ValueError('Wrong type: please select train or test set')
        
        if type_ == 'train':
            return get_null_stats(self.data_train, type_)
        if type_ == 'test':
            return get_null_stats(self.data_test, type_)
    
    #function to check if column has "category" dtype
    def __is_categorical(self, array_like):
        return array_like.dtype.name == 'category'
    
    #method that bands given factor
    #banding here is cutting off all levels that have bigger number of entries then treshold for categorical
    #for numerical on the other hand we use list to create bins
    #Parameters:
    #   1) factor -- factor to be banded
    #   2) threshold -- value for cut off 
    #   3) banding_list -- list for binning
    #   4) label_list -- list to generate labels
    #   5) type_ -- type of variable 
    #               can be 'category' for categorical
    #                      'numeric' for numerical
    #   6) drop_factor -- should programme drop old factor? True if Yes.
    
    def band(self, factor, band_suffix = '_banded', threshold = 1000, banding_list = None, label_list = None, type_ = None, drop_factor = True):
        
        if type_ not in ['category', 'numeric']:
            raise ValueError('Wrong type: type_ should be "category" or "numeric"')
        
        if type(drop_factor) is not bool:
            raise ValueError('Wrong type: drop_factor should be boolean')
        
        #helper function for numerical banding
        def band_num(df_in, factor_, band_suffix, banding_list_, labels_list_):
            df_in[factor] = df_in[factor].astype('float32')
            df_in[factor_ + band_suffix] = pd.cut(df_in[factor], banding_list_, right = False, labels = labels_list_)
        
        #if categorical -- apply treshold
        if type_ == 'category':
            
            factor_suff = factor + band_suffix
            
            #add new columns
            self.data_train[factor_suff] = self.data_train[factor]
            self.data_test[factor_suff] = self.data_test[factor]
            
            counts = self.data_train[factor_suff].value_counts()
            #list of levels/categories to replace for 'Other'
            list_for_replace = counts[counts < threshold].index
            
            #train
            if self.__is_categorical(self.data_train[factor_suff]) and 'Other' not in self.data_train[factor_suff].cat.categories.tolist(): #self.data_train[factor_suff].unique():
                self.data_train[factor_suff] = self.data_train[factor_suff].cat.add_categories("Other")
            self.data_train.loc[self.data_train[factor_suff].isin(list_for_replace), factor_suff] = 'Other'
            
            #test
            if self.__is_categorical(self.data_test[factor_suff]) and 'Other' not in self.data_test[factor_suff].cat.categories.tolist(): #self.data_test[factor_suff].unique():
                self.data_test[factor_suff] = self.data_test[factor_suff].cat.add_categories("Other")
            self.data_test.loc[self.data_test[factor_suff].isin(list_for_replace), factor_suff] = 'Other'
            
            self.banding_dict[factor] = threshold
            self.factor_list.append(factor + band_suffix)
            self.banding_dict_suff[factor + band_suffix] = factor
        
        #if numerical then use pd.cut function
        if type_ == 'numeric':
            
            #automatically create labels if necessary
            if label_list is None:
                labels_list_ = []
                for band in banding_list[:-1]:
                    labels_list_.append(str(band))
            else: 
                labels_list_ = label_list
            
            band_num(self.data_train, factor, band_suffix, banding_list, labels_list_)
            band_num(self.data_test, factor, band_suffix, banding_list, labels_list_)
            
            self.banding_dict[factor] = banding_list
            self.factor_list.append(factor + band_suffix)
            self.banding_dict_suff[factor + band_suffix] = factor
        
        #drop factors
        if drop_factor:
            self.data_train.drop(factor, axis=1, inplace=True)
            self.data_test.drop(factor, axis=1, inplace=True)
            self.factor_list.remove(factor)

    #method that allows to use band method to many factors at once
    #this method is decorated with tqdm
    #Parameters:
    #   1) factor_list_dict -- factors to be banded and tresholds or bins lists 
    #   2) threshold -- value for cut off 
    #   3) drop_factor -- should program drop old factor? True if Yes.
    def band_list(self, factor_list_dict, drop_factor = True, band_suffix = '_banded'):
        
        types_ = set(type(k) for k in factor_list_dict.values())
        if not types_.issubset([int, list]):
            raise ValueError('Wrong type: values of dictionary should be either int or list')
        
        lines_number = len(factor_list_dict)
        with tqdm_notebook(total=lines_number, desc = 'Banding Progress') as pbar:
            for factor, value in factor_list_dict.items():
                if type(value) is list:
                    self.band(factor = factor, band_suffix = band_suffix, banding_list = value, type_ = 'numeric', drop_factor = drop_factor)
                else:
                    self.band(factor = factor, band_suffix = band_suffix, threshold = value, type_ = 'category', drop_factor = drop_factor)
                pbar.update(1)
    
    #plotting section
    
    #returns exposure and observed probabilities for aggregated data
    def __get_data_for_oneway_plots(self, factor):
        #exposure
        bar_data = self.data_train.groupby(factor).agg({factor: lambda x: len(x)})
        bar_data.columns  = ['Amount']
        #probability
        line_data = self.data_train.groupby(factor).agg({self.responce: lambda x: sum(x)/len(x)})
        line_data.columns  = ['Proba']
        x = bar_data.index.tolist()
        #whole datatset mean
        return x, bar_data['Amount'].tolist(), line_data['Proba'].tolist()
    
    def choose_subplot_dimensions(self, k):
        if k < 4:
            return k, 1
        elif k < 11:
            return math.ceil(k/2), 2
        else:
            # I've chosen to have a maximum of 4 columns
            return math.ceil(k/3), 3

    def generate_subplots(self, k, row_wise=False):
        nrow, ncol = self.choose_subplot_dimensions(k)
        figsize=(15 * nrow, 30 * ncol)
        
        # Choose your share X and share Y parameters as you wish:
        figure, axes = plt.subplots(nrow, ncol,
                                    #sharex=True,
                                    sharey=False, figsize=figsize)
        plt.subplots_adjust(wspace = 0.5, hspace = 0.3)

        # Check if it's an array. If there's only one plot, it's just an Axes obj
        if not isinstance(axes, np.ndarray):
            return figure, [axes]
        else:
            # Choose the traversal you'd like: 'F' is col-wise, 'C' is row-wise
            axes = axes.flatten(order=('C' if row_wise else 'F'))

            # Delete any unused axes from the figure, so that they don't show
            # blank x- and y-axis lines
            for idx, ax in enumerate(axes[k:]):
                figure.delaxes(ax)

                # Turn ticks on for the last ax in each column, wherever it lands
                idx_to_turn_on_ticks = idx + k - ncol if row_wise else idx + k - 1
                for tk in axes[idx_to_turn_on_ticks].get_xticklabels():
                    tk.set_visible(True)

            axes = axes[:k]
            return figure, axes 
    
    #method that allows to plot many factors at once (matplotlib)
    #Parameters:
    #   1) factor_list -- factors to be plotted
    #   2) Save -- Should plot be saved?
    #   3) File_path -- Path to file
    def one_way_plots(self, factor_list, Save = False, File_path = None):
        #handle either a list or single string as argument
        if type(factor_list) is not list: factor_list = [factor_list]
        
        figure, axes = self.generate_subplots(len(factor_list), row_wise=True)
        for ax, factor in zip(axes, factor_list):
            print(factor)
            
            x, y_bar, y_line = self.__get_data_for_oneway_plots(factor)
            
            #y-labels
            colname1 = 'Probability'
            colname2 = 'Amount'
            
            #create new axis instance with an invisible x-axis and independent y-axis positioned at right -- for amount
            ax2 = ax.twinx()
            
            color_blue = (114.0/255.0, 147.0/255.0, 203.0/255.0)
            color_orange = (218.0/255.0, 124.0/255.0, 48.0/255.0)

            ax.plot(np.array(x), y_line, color = color_orange, marker="o")
            ax2.bar(np.array(x), y_bar, color = color_blue, align='center')

            #handling x ticks visualisation: rotate tick labels if necessary
            if 25 <= len(max([str(i) for i in x], key=len)) <= 50 or 15 <= len(np.array(x)) <= 20:
                ax.tick_params(axis = 'x', labelrotation = 45)
            if len(max([str(i) for i in x], key=len)) > 50 or len(np.array(x)) > 20:
                ax.tick_params(axis = 'x', labelrotation = 90)


            #define position of ticks and ticklabels: we want amount to be at the right, probability at left.
            ax2.yaxis.tick_right()
            ax.yaxis.tick_left()
            
            #set ticks parameters
            ax.tick_params(axis="y", labelcolor = color_orange, pad=8)
            ax2.tick_params(axis="y", labelcolor = color_blue, pad=8)
            
            #set axis limits and positions
            ax.set_ylim([0.0, 1.1])
            ax.set_yticks((0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0))
            ax.set_yticklabels((r'0%', r'10%', r'20%', r'30%', r'40%', r'50%', r'60%', r'70%', r'80%', r'90%', r'100%'))
            
            #set y labels
            ax.set_ylabel(colname1, color = color_orange)
            ax2.set_ylabel(colname2, color = color_blue)
            
            #put ax in front of ax2: line should be in front of barplot
            ax.set_zorder(ax2.get_zorder()+1) # put ax in front of ax2
            ax.patch.set_visible(False) # hide the 'canvas'
            ax2.patch.set_visible(True) # show the 'canvas'
            
            #set title and its position
            ax.set_title(factor, y=1.02)
            
            #draw horizontal line
            ax.axhline(y = self.mean_proba, color=(245.0/255.0,170.0/255.0,182.0/255.0), linestyle='--')

            fig = ax.get_figure()

        #saving file if flag is true
        if Save:
            fig.savefig(File_path) 
        else: 
            plt.show()

    def one_way_plots_plotly(self, factor_list, Save = False, File_name = None):
        
         #handle either a list or single string as argument
        if type(factor_list) is not list: factor_list = [factor_list]
        
        if len(factor_list) == 1:
            self.one_way_plot_plotly(factor_list[0])
            return
        
        color_blue = 'rgb(114,147,203)'
        color_orange = 'rgb(218,124,48)'
        color_pink = 'rgb(245,170,182)'
        #make subplots
        nrow, ncol = self.choose_subplot_dimensions(len(factor_list))

        subplot_titles = tuple(factor_list)
        fig = tools.make_subplots(rows=nrow, cols=ncol, subplot_titles=subplot_titles,
                                  #horizontal_spacing=0.2,
                                  #vertical_spacing=0.4
                                  )
        data_count = 0
        row = 1
        col = 1
        for i, factor in enumerate(factor_list):
            #y_axis_num = nrow * ncol + i+1
            #y_axis_num = nrow * ncol//len(factor_list)  + i+1
            y_axis_num = len(factor_list) + i +1
            x, y_bar, y_line = self.__get_data_for_oneway_plots(factor)
            trace1 = go.Bar(
                        x=x,
                        y=y_bar,
                        name='Amount per group',
                        marker=dict(
                                color='rgb(114,147,203)'
                                    )
                            )
            trace2 = go.Scatter(
                            x=x,
                            y=y_line,
                            name='Probability per group',
                            marker=dict(
                                    color = 'rgb(218,124,48)'
                                        )
                                )
                            
                            
            trace3 = go.Scatter(
                            x = x,
                            y = [0.5] * len(x),
                            name='Mean Probability',
                            line = dict(
                                    color = ('rgb(245,170,182)'),
                                    width = 1,
                                    dash = 'dash'
                                        ),
                            #marker=dict(
                            #    color = 'rgb(245,170,182)'),
                            mode = 'lines',
                                )
                        
            fig.append_trace(trace1, row, col)
            fig.append_trace(trace2, row, col)
            fig.append_trace(trace3, row, col)

            if col < ncol:
                col+=1
            else:
                row+=1
                col=1
            
            fig['data'][data_count+1].update(yaxis='y'+str(y_axis_num))
            fig['data'][data_count+2].update(yaxis='y'+str(y_axis_num))

            data_count+=3
                
            fig['layout']['yaxis'+str(i+1)].update(
                                               side='right',
                                               showgrid=False,
                                               rangemode='tozero',
                                               title= 'Amount',
                                                   )
            fig['layout']['yaxis'+str(y_axis_num)]=dict(
                                                    overlaying= 'y'+str(i+1),
                                                    anchor= 'x'+str(i+1),
                                                    side= 'left',
                                                    showgrid= True,
                                                    rangemode='tozero',
                                                    title= 'Probability',
                                                    titlefont=dict(
                                                               color='rgb(218,124,48)'
                                                                   ),
                                                    tickfont=dict(
                                                              color='rgb(218,124,48)'
                                                                  ),
                                                    tickmode='array',
                                                    range = [0.0, 1.0],
                                                    tickvals = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
                                                    ticktext = [r'0%', r'10%', r'20%', r'30%', r'40%', r'50%', r'60%', r'70%', r'80%', r'90%', r'100%']
                                                        )
                
        fig['layout'].update(
                         autosize= True,
                         #legend=dict(orientation="h"),
                         title="The Title",
                         width= 800*ncol,
                         height= 400*nrow,
                         showlegend=False,
                         hovermode='x'
                             )
        if Save:
            plotly.offline.plot(fig, filename = File_name, auto_open=False)
        else:
            py.iplot(fig)
    
    

    def one_way_plot_plotly(self, factor, Save = False, File_name = None):

        x, y_bar, y_line = self.__get_data_for_oneway_plots(factor)

        color_blue = 'rgb(114,147,203)'
        color_orange = 'rgb(218,124,48)'
        color_pink = 'rgb(245,170,182)'

        trace1 = go.Bar(
                        x=x,
                        y=y_bar,
                        name='Amount per group',
                        marker=dict(
                                    color = color_blue)
                    )
        trace2 = go.Scatter(
                        x=x,
                        y=y_line,
                        name='Probability per group',
                        yaxis='y2',
                        marker=dict(
                                    color = color_orange)
                    )

        trace3 = go.Scatter(
                        x = x,
                        y = [self.mean_proba] * len(x),
                        name='Mean Probability',
                        yaxis='y2',
                        line = dict(
                            color = color_pink,
                            width = 1,
                            dash = 'dash'),
                        mode = 'lines',
                    )

        plot_data = [trace1, trace2,trace3]

        layout = go.Layout(
#                           legend=dict(orientation="h"),
                            title=factor,
                            yaxis=dict(
                            title='Amount',
                            rangemode='tozero',
                            side='right',
                            showgrid=False,
                            titlefont=dict(
                                color = color_blue
                            ),
                            tickfont=dict(
                                color = color_blue
                            ),
                        ),
                        yaxis2=dict(
                            title='Probability',
                            titlefont=dict(
                                color = color_orange
                            ),
                            tickfont=dict(
                                color = color_orange
                            ),
                            overlaying='y',
                            rangemode='tozero',
                            range=[0.0, 1.1],
                            side='left',
                            tickmode = 'array',
                            tickvals = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
                            ticktext = [r'0%', r'10%', r'20%', r'30%', r'40%', r'50%', r'60%', r'70%', r'80%', r'90%', r'100%']
                        )
                    )
        
        fig = go.Figure(data=plot_data, layout=layout)
        fig['layout'].update(showlegend=False)
        
        if Save:
            plotly.offline.plot(fig, filename = File_name, auto_open=False)
        else:
            py.iplot(fig)
        
    #returns dictionary with lists of excess levels per factor
    def missed_values_test(self, factor_list):
        excess_level_dict = {}
        for fac in factor_list:
            excess_level_dict[fac] = list(set(self.data_test[fac])- set(self.data_train[fac])) 
        return excess_level_dict
    
    #method for replacing NaNs 
    #this metod works different for different data types
    #Parameters:
    #   1) factor -- factors to be processed
    #   2) type_ can be 'NA' for categorical
    #                   'Mode' for categorical or numerical
    #                   'Numeric' for numerical
    def replace_NA(self, factor, type_):

        if type_ not in ['NA', 'Mode', 'Numeric']:
            raise ValueError('Wrong type: type_ should be "Na", "Mode" or "Numeric"')
        
        if type_ == 'NA':
            #in case of strings, not categories  and if "NA" is already present in categories
            if self.__is_categorical(self.data_train[factor]) and 'NA' not in self.data_train[factor].cat.categories.tolist(): #self.data_train[factor].unique(): -- check for values
                self.data_train[factor] = self.data_train[factor].cat.add_categories("NA")
            self.data_train[factor] = self.data_train[factor].fillna("NA")
            
            if self.__is_categorical(self.data_test[factor]) and 'NA' not in self.data_test[factor].cat.categories.tolist():
                self.data_test[factor] = self.data_test[factor].cat.add_categories("NA")
            self.data_test[factor] = self.data_test[factor].fillna("NA")
                
        if type_ == 'Mode':
            self.data_train[factor] = self.data_train[factor].fillna(self.data_train[factor].mode()[0])
            self.data_test[factor] = self.data_test[factor].fillna(self.data_train[factor].mode()[0])
        
        if type_ == 'Numeric':
            self.data_train[factor] = self.data_train[factor].fillna(self.data_train[factor].mean())
            self.data_test[factor] = self.data_test[factor].fillna(self.data_train[factor].mean())
    
    #method for generate WOE factors
    #Parameters:
    #   1) factor -- factors to be processed
    #def generate_WOE(self, factor):
    #    df_grouped = self.data_train.groupby(factor).agg({'HasDetections': {'bad' : lambda x: sum(x)/len(x), 'good' : lambda y: 1- sum(y)/len(y)} })
    #    df_grouped.columns = df_grouped.columns.droplevel()
    #    df_grouped['WOE'] = np.log(df_grouped['bad']/df_grouped['good'])
    #    df_grouped['WOE'] = df_grouped['WOE'].replace(-np.inf,np.NaN)
    #    df_grouped['WOE'] = df_grouped['WOE'].fillna(df_grouped['WOE'].min(skipna = True))
    #    df_grouped['WOE'] = df_grouped['WOE'].replace(np.inf,np.NaN)
    #    df_grouped['WOE'] = df_grouped['WOE'].fillna(df_grouped['WOE'].max(skipna = True))
    #    max = df_grouped['WOE'].max()
    #    min = df_grouped['WOE'].min() 
    #    #step = (max - min)*0.05
    #    banding_list = np.linspace(min,max+0.1, 100 )
    #    labels_list = range(len(banding_list)-1)
    #    df_grouped['WOE' + self.band_suffix] = pd.cut(df_grouped['WOE'], banding_list, right = False, labels = labels_list)
    #    df_grouped_dict = dict(zip(df_grouped.index, df_grouped['WOE' + self.band_suffix]))
    #    self.data_train[factor + '_WOE'] = self.data_train[factor].replace(df_grouped_dict)
    #    self.data_test[factor + '_WOE'] = self.data_test[factor].replace(df_grouped_dict)
    
    #method for generate distrubution statistics
    #Parameters:
    #   1) factor -- factors to be processed
    #   2) id_column -- if none use id_column from constructor
    #   3) order_by -- sorting method can be  'desc' -- for descending sorting
    #                                         'asc'  -- for asc sorting  
    #                                         'key' -- for factor sorting                           
    def get_value_counts(self, factor, type_='train', order_by='desc', dropna=True):
        def get_value_counts_type(df, factor, type_, order_by, dropna):
            if order_by == 'key':
                return df[factor].value_counts(dropna = dropna).sort_index()
            if order_by == 'desc':
                return df[factor].value_counts(dropna = dropna)
            if order_by == 'asc':
                return df[factor].value_counts(ascending = True, dropna = dropna)

        if type_ not in ['train', 'test']:
            raise ValueError('Wrong type: please select train or test set')
        
        if order_by not in ['key', 'desc', 'asc']:
            raise ValueError('Wrong type: order_by should be one of "desc", "asc" or "key"')

        if type_ == 'train':
            return get_value_counts_type(self.data_train, factor, type_, order_by, dropna)
        if type_ == 'test':
            return get_value_counts_type(self.data_test, factor, type_, order_by, dropna)
